-- TABLE DESIGN THAT WORKS FOR YOU

-- Following Naming Conventions
		-- camel case -> berrySmoothie
		-- pascal case -> BerrySmoothie
		-- snake case -> berry_smoothie

-- Quoting Identifiers Enables Mixed Case
CREATE TABLE customers (
    customer_id text,
    --snip--
);
-- The second statement, rather than creating a separate table called Customers, 
-- will throw an error: relation "customers" already exists.
CREATE TABLE Customers (
    customer_id text,
    --snip--
);

CREATE TABLE "Customers" (
    customer_id serial,
    --snip--
);
-- However, because this requires that to query Customers rather than customers, 
-- you have to quote its name in the SELECT statement:

SELECT * FROM "Customers";
-- That can be a chore to remember and makes a user vulnerable to a mix-up. 
-- Make sure your tables have names that are clear and distinct from other tables in the database.

-- Pitfalls with Quoting Identifiers
-- For PostgreSQL, you can find a list of keywords documented at https://www.postgresql.org/docs/current/sql-keywords-appendix.html. 
-- In addition, many code editors and database tools, including pgAdmin, automatically highlight keywords in a particular color.

-- Guidelines for Naming Identifiers
	-- Use snake case.
	-- Make names easy to understand and avoid cryptic abbreviations.
	-- For table names, use plurals.
	-- Mind the length. (SQL-128, PostgreSQL-63, older Oracle-30)
	-- When making copies of tables, use names that will help you manage them later.
		-- One method is to append a _YYYY_MM_DD date to the table name when you create the copy, 
		-- such as vehicle_parts_2021_04_08. An additional benefit is that the table names will sort in date order.


-- Controlling Column Values with Constraints
-- In Chapter 7, you learned about PRIMARY and FOREIGN KEYS, which are two of the most commonly used constraints.

-- SQL also has the following constraint types:
	-- CHECK: Allows only those rows where a supplied Boolean expression evaluates to true
	-- UNIQUE: Ensures that values in a column or group of columns are unique in each row in the table
	-- NOT NULL: Prevents NULL values in a column

-- We can add constraints in two ways: as a column constraint or as a table constraint.

-- Primary Keys: Natural vs. Surrogate

-- A primary key is a column or collection of columns whose values uniquely identify each row in a table. 
-- A primary key is a constraint, and it imposes two rules on the column or columns that make up the key:
		-- Values must be unique for each row.
		-- No column can have missing values.
		
-- NATURAL KEY -> uses one or more of the table’s existing columns that meet the criteria for a primary key: 
	-- unique for every row and never empty. 
	-- Values in the columns can change as long as the new value doesn’t cause a violation of the constraint.


-- Introducing Columns for SURROGATE KEYS

-- A surrogate key is a single column that you fill with artificial values; 
-- we might use it when a table doesn’t have data that supports creating a natural primary key. 
-- The surrogate key might be a sequential number autogenerated by the database.
	-- PostgreSQL offers a UUID data type as well as two modules that generate UUIDs: uuid-ossp and pgcrypto. 
	-- The PostgreSQL documentation at https://www.postgresql.org/docs/current/datatype-uuid.html is a good starting point for diving deeper.


-- Creating a Single-Column Primary Key

-- There are two ways to declare constraints: as a column constraint or as a table constraint:

-- As a column constraint
CREATE TABLE natural_key_example (
    license_id text CONSTRAINT license_key PRIMARY KEY,
    first_name text,
    last_name text
);
-- As a column constraint => omitting CONSTRAINT + name
-- In that case, PostgreSQL will name the primary key on its own, 
-- using the convention of the table name followed by _pkey => natural_key_example_pkey.
CREATE TABLE natural_key_example (
    license_id text PRIMARY KEY,
    first_name text,
    last_name text
);

SELECT * FROM natural_key_example;
DROP TABLE natural_key_example;

-- As a table constraint
CREATE TABLE natural_key_example (
    license_id text,
    first_name text,
    last_name text,
    CONSTRAINT license_key PRIMARY KEY (license_id)
);
-- or again omitting CONSTRAINT + key name:
CREATE TABLE natural_key_example (
    license_id text,
    first_name text,
    last_name text,
    PRIMARY KEY (license_id)
);
-- You must use the table constraint syntax when you want to create a primary key using more than one column;
-- in that case, you would list the columns in parentheses, separated by commas.

-- Listing 8-2: Example of a primary key violation
-- Note: You will need to create the natural_key_example table
-- using either of the two statements in Listing 8-1.

INSERT INTO natural_key_example (license_id, first_name, last_name)
VALUES ('T229901', 'Gem', 'Godfrey');

INSERT INTO natural_key_example (license_id, first_name, last_name)
VALUES ('T229901', 'John', 'Mitchell');


-- Creating a Composite Primary Key

-- If a single column doesn’t meet the requirements for a primary key, we can create a composite primary key.
-- We’ll make a table that tracks student school attendance. 
-- The combination of student_id and school_day columns gives us a unique value for each row, 
-- which records whether a student was in school on that day in a column called present. 
-- To create a composite primary key, you must declare it using the table constraint syntax.

CREATE TABLE natural_key_composite_example (
    student_id text,
    school_day date,
    present boolean,
    CONSTRAINT student_key PRIMARY KEY (student_id, school_day)
);

INSERT INTO natural_key_composite_example (student_id, school_day, present)
VALUES(775, '2022-01-22', 'Y');

INSERT INTO natural_key_composite_example (student_id, school_day, present)
VALUES(775, '2022-01-23', 'Y');

INSERT INTO natural_key_composite_example (student_id, school_day, present)
VALUES(775, '2022-01-23', 'N');

SELECT * FROM natural_key_composite_example;

-- You can create composite keys with more than two columns. 
-- The limit to the number of columns you can use depends on your database.



-- Creating an Auto-Incrementing Surrogate Key

-- As you learned in “Auto-Incrementing Integers” in Chapter 4, there are two ways to have a PostgreSQL 
-- database add an automatically increasing unique value to a column:
		-- The first is to set the column to one of the PostgreSQL-specific serial data types: 
				-- smallserial, serial, and bigserial. 
		-- The second is to use the IDENTITY syntax; because it is part of the ANSI SQL standard, 
		-- we’ll employ this for our examples.
		
CREATE TABLE surrogate_key_example (
    order_number bigint GENERATED ALWAYS AS IDENTITY,
    product_name text,
    order_time timestamp with time zone,
    CONSTRAINT order_number_key PRIMARY KEY (order_number)
);

INSERT INTO surrogate_key_example (product_name, order_time)
VALUES ('Beachball Polish', '2020-03-15 09:21-07'),
       ('Wrinkle De-Atomizer', '2017-05-22 14:00-07'),
       ('Flux Capacitor', '1985-10-26 01:18:00-07');

SELECT * FROM surrogate_key_example;

-- You can, however, allow manual insertions by restarting the IDENTITY sequence. 
-- You might allow this in case you need to insert a row that was mistakenly deleted.
-- You can, however, allow manual insertions by restarting the IDENTITY sequence. 
-- You might allow this in case you need to insert a row that was mistakenly deleted. 
-- It shows how to add a row to the table that has an order_number of 4, 
-- which is the next value in the sequence:

INSERT INTO surrogate_key_example
OVERRIDING SYSTEM VALUE
VALUES (4, 'Chicken Coop', '2021-09-03 10:33-07');

ALTER TABLE surrogate_key_example ALTER COLUMN order_number RESTART WITH 5;

INSERT INTO surrogate_key_example (product_name, order_time)
VALUES ('Aloe Plant', '2020-03-15 10:09-07');

-- If you select all rows again from the surrogate_key_example table, 
-- you’ll see that the order_number column populated as intended:

SELECT * FROM surrogate_key_example;


-- Foreign Keys

-- We use foreign keys to establish relationships between tables. 
-- A foreign key is one or more columns whose values match those in another table’s primary key 
-- or other unique key. 
-- Foreign key values must already exist in the primary key or other unique key of the table it references.
-- If not, the value is rejected. 
-- With this constraint, SQL enforces referential integrity—ensuring that data in related tables 
-- doesn’t end up unrelated, or orphaned. 
-- We won’t end up with rows in one table that have no relation to rows in the other tables 
-- we can join them to.

CREATE TABLE licenses (
    license_id text,
    first_name text,
    last_name text,
    CONSTRAINT licenses_key PRIMARY KEY (license_id)
);

CREATE TABLE registrations (
    registration_id text,
    registration_date timestamp with time zone,
    license_id text REFERENCES licenses (license_id),
    CONSTRAINT registration_key PRIMARY KEY (registration_id, license_id)
);

INSERT INTO licenses (license_id, first_name, last_name)
VALUES ('T229901', 'Steve', 'Rothery');

INSERT INTO registrations (registration_id, registration_date, license_id)
VALUES ('A203391', '2022-03-17', 'T229901');

INSERT INTO registrations (registration_id, registration_date, license_id)
VALUES ('A75772', '2022-03-17', 'T000001');

-- The first table, licenses, uses a driver’s unique license_id as a natural primary key. 
-- The second table, registrations, is for tracking vehicle registrations. 
-- A single license ID might be connected to multiple vehicle registrations, 
-- because each licensed driver can register multiple vehicles—this is called a one-to-many relationship (Chapter 7).

-- Here’s how that relationship is expressed via SQL: 
-- in the registrations table, we designate the column license_id as a foreign key 
-- by adding the REFERENCES keyword, followed by the table name and column for it to reference.


-- How to Automatically Delete Related Records with CASCADE

-- To delete a row in licenses and have that action automatically delete any related rows in registrations,
-- we can specify that behavior by adding ON DELETE CASCADE when defining the foreign key constraint.

DROP TABLE registrations;

CREATE TABLE registrations (
    registration_id text,
    registration_date date,
    license_id text REFERENCES licenses (license_id) ON DELETE CASCADE
    CONSTRAINT registration_key PRIMARY KEY (registration_id, license_id)
);
-- Deleting a row in licenses should also delete all related rows in registrations.



-- The CHECK Constraint

-- A CHECK constraint evaluates whether data added to a column meets the expected criteria, 
-- which we specify with a logical test.
-- As with primary keys, we can implement a CHECK constraint at the column or table level.

	-- For a column constraint, declare it in the CREATE TABLE statement after the column name and data type: 
	-- CHECK (logical expression).
	
	-- As a table constraint, use the syntax CONSTRAINT constraint_name CHECK (logical expression) 
	-- after all columns are defined.

CREATE TABLE check_constraint_example (
    user_id bigint GENERATED ALWAYS AS IDENTITY,
    user_role text,
    salary numeric(10,2),
    CONSTRAINT user_id_key PRIMARY KEY (user_id),
    CONSTRAINT check_role_in_list CHECK (user_role IN('Admin', 'Staff')),
    CONSTRAINT check_salary_not_below_zero CHECK (salary >= 0)
);

-- Both of these will fail:
INSERT INTO check_constraint_example (user_role)
VALUES ('admin');

INSERT INTO check_constraint_example (salary)
VALUES (-10000);

-- If we use the table constraint syntax, we also can combine more than one test 
-- in a single CHECK statement. Say we have a table related to student achievement. 
-- We could add the following:
CONSTRAINT grad_check CHECK (credits >= 120 AND tuition = 'Paid')
-- Notice that we combine two logical tests by enclosing them in parentheses and connecting them with AND.
-- Here, both Boolean expressions must evaluate as true for the entire check to pass. 

-- You can also test values across columns, as in the following example where we want to make sure
-- an item’s sale price is a discount on the original, assuming we have columns for both values:
CONSTRAINT sale_check CHECK (sale_price < retail_price)
-- Inside the parentheses, the logical expression checks that the sale price is less than the retail price.



-- The UNIQUE Constraint

-- We can also ensure that a column has a unique value in each row by using the UNIQUE constraint.
-- If ensuring unique values sounds similar to the purpose of a primary key, it is. 
-- But UNIQUE has one important difference. In a primary key, no values can be NULL, 
-- but a UNIQUE constraint permits multiple NULL values in a column. 
-- This is useful in cases where we won’t always have values 
-- but want to ensure that the ones we do have are unique.

CREATE TABLE unique_constraint_example (
    contact_id bigint GENERATED ALWAYS AS IDENTITY,
    first_name text,
    last_name text,
    email text,
    CONSTRAINT contact_id_key PRIMARY KEY (contact_id),
    CONSTRAINT email_unique UNIQUE (email)
);

INSERT INTO unique_constraint_example (first_name, last_name, email)
VALUES ('Samantha', 'Lee', 'slee@example.org');

INSERT INTO unique_constraint_example (first_name, last_name, email)
VALUES ('Betty', 'Diaz', 'bdiaz@example.org');

INSERT INTO unique_constraint_example (first_name, last_name, email)
VALUES ('Sasha', 'Lee', 'slee@example.org');


-- The NOT NULL Constraint

-- In Chapter 7, you learned about NULL, a special SQL value that represents missing data or unknown values.
-- We know that NULL is not allowed for primary key values because they need to uniquely identify each row
-- in a table. But there may be other times when you’ll want to disallow empty values in a column. 
-- For example, in a table listing each student in a school, requiring that columns containing 
-- first and last names be filled for each row makes sense. To require a value in a column, 
-- SQL provides the NOT NULL constraint, which simply prevents a column from accepting empty values.

CREATE TABLE not_null_example (
    student_id bigint GENERATED ALWAYS AS IDENTITY,
    first_name text NOT NULL,
    last_name text NOT NULL,
    CONSTRAINT student_id_key PRIMARY KEY (student_id)
);

DROP TABLE not_null_example;

-- How to Remove Constraints or Add Them Later

-- You can remove a constraint or later add one to an existing table using ALTER TABLE, 
-- the command you used earlier in the chapter in “Creating an Auto-incrementing Surrogate Key” 
-- to reset the IDENTITY sequence.

-- To remove a primary key, foreign key, or UNIQUE constraint, you write an ALTER TABLE statement 
-- in this format:
		-- ALTER TABLE table_name DROP CONSTRAINT constraint_name;

-- To drop a NOT NULL constraint, the statement operates on the column, 
-- so you must use the additional ALTER COLUMN keywords, like so:

		-- ALTER TABLE table_name ALTER COLUMN column_name DROP NOT NULL;

-- Let’s use these statements to modify the not_null_example table you just made, as shown in Listing 8-11.

ALTER TABLE not_null_example DROP CONSTRAINT student_id_key;
ALTER TABLE not_null_example ADD CONSTRAINT student_id_key PRIMARY KEY (student_id);
ALTER TABLE not_null_example ALTER COLUMN first_name DROP NOT NULL;
ALTER TABLE not_null_example ALTER COLUMN first_name SET NOT NULL;

-- NOTE
-- You can add a constraint to an existing table only if the data in the 
-- target column obeys the limits of the constraint. 
-- For example, you can’t place a primary key constraint on a column 
-- that has duplicate or empty values.



-- Speeding Up Queries with Indexes

-- B-Tree: PostgreSQL’s Default Index:
	-- B-tree, short for balanced tree, is so named because when you search 
	-- for a value, the structure looks from the top of the tree down through 
	-- branches until it locates the value.
		-- A B-tree index is useful for data that can be ordered and searched 
		-- using equality and range operators, such as <, <=, =, >=, >, and BETWEEN. 
		-- It also works with LIKE if there’s no wildcard in the pattern 
		-- at the beginning of the search string. An example is WHERE chips LIKE 'Dorito%'.
		
		
-- PostgreSQL also supports additional index types, 
-- such as the Generalized Inverted Index (GIN) and 
-- the Generalized Search Tree (GiST). 
-- Each has distinct uses, and I’ll incorporate them in later chapters 
-- on full-text search and queries using geometry types.

CREATE TABLE new_york_addresses (
    longitude numeric(9,6),
    latitude numeric(9,6),
    street_number text,
    street text,
    unit text,
    postcode text,
    id integer CONSTRAINT new_york_key PRIMARY KEY
);

COPY new_york_addresses
FROM '/Users/dmitrijvaledinskij/SQL/practical-sql-2-main/Chapter_08/city_of_new_york.csv'
WITH (FORMAT CSV, HEADER);

SELECT * FROM new_york_addresses;



-- Benchmarking Query Performance with EXPLAIN

-- We’ll measure the performance before and after adding an index by using 
-- the PostgreSQL-specific EXPLAIN command, which lists the query plan 
-- for a specific database query. The query plan might include 
-- how the database plans to scan the table, 
-- whether or not it will use indexes, and so on. 
-- When we add the ANALYZE keyword, EXPLAIN will carry out the query 
-- and show the actual execution time.

-- Recording Some Control Execution Times

EXPLAIN ANALYZE SELECT * FROM new_york_addresses
WHERE street = 'BROADWAY'; -- ~40 ms => after indexing: 2 ms

-- SELECT street, street_number, postcode
-- FROM new_york_addresses
-- WHERE street = 'BROADWAY'

EXPLAIN ANALYZE SELECT * FROM new_york_addresses
WHERE street = '52 STREET'; -- ~40 ms => after indexing: 0.7 ms

EXPLAIN ANALYZE SELECT * FROM new_york_addresses
WHERE street = 'ZWICKY AVENUE'; -- ~40 ms => after indexing: 0.04 ms


-- Adding the Index

-- Now, let’s see how adding an index changes the query’s search method and execution time.

-- Listing 8-14: Creating a B-tree index on the new_york_addresses table

CREATE INDEX street_idx ON new_york_addresses (street);

-- Notice that it’s similar to the commands for creating constraints. 
-- We give the CREATE INDEX keywords followed by a name we choose for the index, 
-- in this case street_idx. Then ON is added, followed by the target table and column.

-- If you ever need to remove an index from a table 
-- — perhaps if you’re testing the performance of several index types 
-- — use the DROP INDEX command followed by the name of the index to remove.


-- Considerations When Using Indexes

-- Consult the documentation for the database system you’re using to learn about the kinds 
-- of indexes available and which to use on particular data types. 
-- PostgreSQL, for example, has five more index types in addition to B-tree.

-- One, called GiST, is particularly suited to the geometry data types

-- Full-text search also benefits from indexing.


-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Consider adding indexes to columns you’ll use in table joins. Primary keys are indexed by default in PostgreSQL, 
-- but foreign key columns in related tables are not and are a good target for indexes.
-- An index on a foreign key will help avoid an expensive sequential scan during a cascading delete.
-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!



-- Add indexes to columns that will frequently end up in a query WHERE clause. 
-- As you’ve seen, search performance is significantly improved via indexes.

-- Use EXPLAIN ANALYZE to test the performance under a variety of configurations. 
-- Optimization is a process! If an index isn’t being used by the database — 
-- and it’s not backing up a primary key or other constraint — you can drop it 
-- to reduce the size of your database and speed up inserts, updates, and deletes.
